= TWISTER APPLICATION PROGRAMMERS GUIDE
:docinfo:
[preface]

== Introduction
This document gives an overview of the modules build in Twister API and how an application is built on it. The detailed definitions and individual function calls can be found in the doc folder of Twister API. 
At start, the document explains the core modules of twister API, these include initialization module, event loop, ARP table management and JSON parsing. Details of build system are also included.
After that, it explains the sample application step by step to give programmer an example of API usage. The Appendices contain information to debug any relevant issues. 
The best way to start is to go through the Sample Applications Details Section initially while reviewing the code of the sample application and then go through the whole document for complete understanding of design of Twister API and application development on top of it. 



== Initialization Module
The initialization module of API handles the initialization of twister abstraction layer. Abstraction layer consists of the following parts:

* System Memory Reservation: The abstraction layer facilitates the reservation of different memory zones, for example, physical memory areas for device interactions.
* Allocate PCI resources and set up the physical device and the link
* Initialize statistics counters
* Link Up/Down control and notification interrupt. This is the only interrupt that a PMD handles
* Port and Queue setup for both RX and TX
* Access the RX and TX descriptors directly without any interrupts
* Assign user specified parameters to the physical device.
In the Twister API, all the above initialization steps are formed by single API call which is: *tw_init_global(argc, argv)*

The user specified parameters for the physical device are provided in the “port_conf” file. This file must be present in the application directory. The parameters are further explained in the below section:

=== Port Management 
The port management is assigning specific parameters which include IP address, subnet mask, gateway IP to the port. All this is done in the initialization module. The user just hast to provide a file to the module, which is *port_conf*. The configuration file should be in JSON format and a sample is provided below:

*port_conf* file is array of JSON fields. Each array '[port_name: <>, ip_addrs:<>]' corresponds to one port:

* port_name: This is an identifier that lists the port name. The port name is assigned by Twister Virtual Machine (TVM)OS. TVM assigns the port name as *tw<X>* according to the PCI ID in a numerical order. So if a TVM has two ports, the port name for first one will be tw0 and for the second one will be tw1.
* ip_addrs: This field lists the IP address range to be assigned for the port. It contains two sub fields:

a. start_ip_addr: IP address in string format, assigned to the port.
b. num_ip_addrs: This number specify the range of IP addresses for this port.
c. gateway_ip: It will list the gateway for this particular port.
d. subnet_mask: The mask to determine the subnet of this port. 

* For an application using multiple ports e.g. 2, the format of port_conf would be i.e. 
[
       [
       “port_name”:“tw0”
	“ip_addrs”:[]
       ],
       [
       “port_name”:”tw1”
	“ip_addrs”:[]
       ]
]  


== Event loop
Twister API provides an event loop which is based on *libuv* model with general flow shown below:


The Twister API implementation of event loop has the following features:

a. Event callback registration: Users can register three types of handles in the loop. 

* RX handle: These handles are used for receiving packets. Currently only one RX handle is supported. This callback is called when any type of packet is received.
* TX handle: Multiple TX handles can be registered. Each handle’s callback will be called once per event loop iteration.
* Timer handle: This handle’s callback will be called after a fixed timeout.

b. With each instance of a handle, one callback function is registered. This is called when the event has occurred.

=== Comparison of twister API calls and Libuv calls are given below:

[width="15%"]
|===============================================================================================================================
|*Sr.* | *Twister* | *Libuv*
|1.  | *tw_default_loop:* Reserve memory for an event loop with which handles can be registered. The loop’s total time to run is also provided | *uv_default_loop:* Reserve memory for an event loop with which handles can be registered
|2.  | *tw_<handlename>_init:* Reserve memory for handle pointer and register it with an event loop instance | *uv_<handlename>_init:* Reserve memory for handle pointer and register it with an event loop instance
|3.  | *tw_<handlename>_start:* Register a callback function for the handle| *uv_<handlename_start>:* Register a callback function for the handle
|4.  | *tw_run:* Start the event loop | *uv_run:* Start the event loop
|===============================================================================================================================


== ARP Table
The Twister API has built-in ARP functionality which user can utilize in their application using simple calls. The API will maintain the table locally. If application is sending a packet whose MAC is not known, the API will store the packet in the queue and generate an ARP query for the IP and automatically update the queued packets once the ARP respond is received.
The API can also respond to the ARP query for the IP addresses of the interfaces which the API is handling. The application programmer just has to add the *tw_arp_parser* in the application flow. Rest will be the job of the API. To list all the ARP functions and their usage, kindly use the Twister API Reference documentation provided on Github. It can be accessed the *twister/documentation/html/index.html* file.



== Building the Applications

=== Cloning the Repository

Clone the desired branch from dell twister repository (https://github.com/delltwister/twister). Navigate to the directory of desired example. 

=== Compiling a Sample Application
The sample applications can be built using the following commands:
--------------------------------------
	make clean
	make
--------------------------------------
=== Customizing the Application Makefile
The default Makefile provided with the UDP Echo sample application is a good starting point. It includes:

* twister.mk at the beginning

The user must define following variables:

* APP: Contains the name of the application.
* SRCS: List of source files (*.c).
The rest of the Makefile can be customized as a normal Makefile.



== Sample Applications Details
The general flow of Twister API applications is as follows:

There are three sample applications developed for Twister API release 0.1. They include the following:

a. UDP Send Application: This application is a tester client application which generates UDP traffic by sending timestamp to an echo server. It also receives any timestamps echoed back and calculates RTT.
b. UDP Echo Application: This application receives the UDP traffic and echo back to the sender.
c. Ethernet Echo Application: This application is a simple Layer 2 forward application which simply echo every packet it received by changing the MAC.
The UDP Echo server application is discussed below:

== Writing a New Application
The best way to start writing a new application is to copy an existing Twister API application and modify it. To list the functions and their usage, kindly use the Twister API Reference documentation provided on GitHub. It can be accessed from *twister/documentation/html/index.html* file. 

== Appendices

=== HW/SW Information Relating to Twister API

Intel® DPDK Version: 2.0.0

Linux Kernel Version: 3.11.0-12-generic
	
Linux Version: Ubuntu 12.04

Twister VM Architecture: x86_64

CPU Model: Intel Xeon E312xx (Sandy Bridge)

GCC Version: 4.8.1

Intel® NICs Used for testing purposes: Virtual Functions of Intel x520 and x540 Dual Port 10G NICs


 

